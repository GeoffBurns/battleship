<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>No-Touch Battleship – 18×7</title>

    <meta
      name="description"
      content="Play a challenging version of Battleship with no-touch placement rules and special ships."
    />

    <link rel="stylesheet" href="battleseek.css" />
  </head>
  <body>
    <style type="text/css">
      .battleship {
        box-sizing: border-box;
      }
      .panel {
        background: #0e1530;
        padding: 12px;
        border-radius: 10px;
        border: 1px solid #1b2746;
      }
      .board-wrap {
        background: #0e1530;
        padding: 12px;
        border-radius: 10px;
        margin-bottom: 12px;
        border: 1px solid #1b2746;
      }
      .board {
        display: grid;
        grid-template-columns: repeat(var(--cols), var(--boxSize));
        grid-template-rows: repeat(var(--rows), var(--boxSize));
        gap: 0px;
      }
      /* destroyed (desaturated) board   */
      .board.destroyed .land.light,
      .board.destroyed .sea.light {
        background: #777;
      }
      .board.destroyed .land.dark,
      .board.destroyed .sea.dark {
        background: #555;
      }
      .cell {
        width: var(--boxSize);
        height: var(--boxSize);
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        cursor: pointer;
        box-sizing: border-box;
      }
      .cell.land.light {
        background: #348239;
      }
      .cell.land.dark {
        background: #296334;
      }
      .cell.sea.light {
        background: #1a78d6;
      }
      .cell.sea.dark {
        background: #1761b0;
      }
      .cell.rightEdge.light {
        height: 115%;
        border-right: 2px solid #024;
      }
      .cell.bottomEdge.light {
        border-bottom: 2px solid #024;
      }
      .cell.rightEdge.dark {
        height: 115%;
        border-right: 2px solid #000;
      }
      .cell.bottomEdge.dark {
        border-bottom: 2px solid #000;
      }
      .cell.leftEdge.light {
        border-left: 2px solid #000;
      }
      .cell.leftEdge.dark {
        border-left: 2px solid #000;
      }
      .cell.miss::after {
        content: '';
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background: #91a3c6;
      }
      .cell.hit {
        color: #ff3b3b;
      }
      .cell.hit::after {
        content: 'X';
        font-size: 80%;
        font-family: Arial, Helvetica, sans-serif;
        font-weight: 900;
        color: #ff3b3b;
      }
      .tally-row {
        display: flex;
        gap: 6px;
        margin-bottom: 8px;
        align-items: center;
      }
      .tally-box {
        width: 28px;
        height: 22px;
        border-radius: 4px;
        border: 1px solid rgba(200, 210, 240, 0.06);
        display: grid;
        place-items: center;
        font-weight: 700;
      }
      button {
        padding: 8px 10px;
        border-radius: 8px;
        border: none;
        background: #2b4066;
        color: #aaccff;
        cursor: pointer;
      }
      button:disabled {
        opacity: 0.45;
        cursor: not-allowed;
      }
      span.shortcut {
        color: #fff;
        font-weight: 900;
      }
      .status {
        margin-top: 8px;
        color: #111;
        font-size: 150%;
      }
      .info {
        color: #fff;
      }

      h2 {
        margin: 0 0 12px 0;
      }
    </style>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>No-Touch Battleship – 18×7</title>

    <meta
      name="description"
      content="Play a challenging version of Battleship with no-touch placement rules and special ships."
    />
    <div class="battleship" style="width: 536px">
      <div style="margin-bottom: 30px; margin-top: 30px">
        <label for="chooseMap" style="font-size: 130%; font-weight: 900"
          >Choose a Map:
        </label>
        <select
          id="chooseMap"
          style="font-size: 120%; font-weight: bold"
        ></select>
      </div>
      <div class="container">
        <h2 style="text-align: center">Enemy Waters</h2>
        <div class="board-wrap" style="width: 520px">
          <div aria-label="game board" class="board" id="enemy-board"></div>
        </div>
        <div
          class="status"
          style="
            font-weight: bold;
            height: 52px;
            margin-bottom: 30px;
            margin-top: 45px;
          "
        >
          <div
            id="gameStatus"
            style="float: left; text-align: left; width: 65%"
          >
            Click On Square To Fire
          </div>
          <div
            id="modeStatus"
            style="float: right; text-align: right; width: 35%"
          >
            Single Shot Mode
          </div>
        </div>
        <div class="panel" style="display: flex; gap: 16px">
          <div
            style="
              display: flex;
              flex-direction: column;
              gap: 8px;
              margin-bottom: 8px;
            "
          >
            <button id="newGame"><span class="shortcut">R</span>estart</button>
            <button id="carpetBtn">
              <span class="shortcut">M</span>ega Bomb
            </button>
            <button id="revealBtn">Re<span class="shortcut">v</span>eal</button>
          </div>
          <div>
            <h4 style="color: white; margin-bottom: 12px">Tally Boxes</h4>
            <div id="enemy-tallyBox"></div>
          </div>
          <div>
            <div class="info">Shots: <span id="enemy-shots">0 </span></div>
            <div class="info">Hits: <span id="enemy-hits">0 </span></div>
            <div class="info">Sunk: <span id="enemy-sunk">0 / 8</span></div>
          </div>
        </div>
      </div>
    </div>

    <script type="text/javascript">
      //<![CDATA[
      ;(() => {
        const maps = [
          {
            title: 'Jaggered Coast SS',
            ROWS: 7,
            COLS: 18,
            SHIP_NUM: { A: 1, B: 1, C: 1, D: 1, P: 2, G: 1, U: 1, M: 3 },
            LAND_AREA: [
              [2, 16, 17],
              [2, 0, 2],
              [2, 16, 17],
              [3, 0, 3],
              [3, 15, 17],
              [4, 15, 17],
              [5, 15, 17],
              [6, 15, 17],
              [4, 0, 7],
              [5, 0, 8],
              [6, 0, 8]
            ]
          },
          {
            title: 'Jaggered Coast S',
            ROWS: 7,
            COLS: 19,
            SHIP_NUM: { A: 1, B: 1, C: 1, D: 2, P: 2, G: 1, U: 1, M: 3 },
            LAND_AREA: [
              [1, 16, 18],
              [2, 0, 2],
              [2, 16, 18],
              [3, 0, 3],
              [3, 15, 18],
              [4, 15, 18],
              [5, 15, 18],
              [6, 15, 18],
              [4, 0, 7],
              [5, 0, 8],
              [6, 0, 8]
            ]
          },
          {
            title: 'Jaggered Coast MS',
            ROWS: 8,
            COLS: 18,
            SHIP_NUM: { A: 1, B: 1, C: 1, D: 2, P: 2, G: 1, U: 1, M: 3 },
            LAND_AREA: [
              [2, 14, 16],
              [3, 0, 2],
              [3, 14, 17],
              [4, 0, 3],
              [4, 14, 17],
              [5, 14, 17],
              [6, 14, 17],
              [7, 14, 17],
              [5, 0, 8],
              [6, 0, 10],
              [7, 0, 10]
            ]
          },
          {
            title: 'Jaggered Coast M',
            ROWS: 9,
            COLS: 17,
            SHIP_NUM: { A: 1, B: 1, C: 1, D: 1, P: 2, G: 2, U: 1, M: 3 },
            LAND_AREA: [
              [3, 13, 15],
              [4, 0, 2],
              [4, 13, 16],
              [5, 0, 3],
              [5, 13, 16],
              [6, 0, 9],
              [6, 13, 16],
              [7, 0, 16],
              [8, 0, 16]
            ]
          },
          {
            title: 'Jaggered Coast ML',
            ROWS: 9,
            COLS: 18,
            SHIP_NUM: { A: 1, B: 1, C: 1, D: 2, P: 2, G: 2, U: 1, M: 3 },
            LAND_AREA: [
              [3, 14, 16],
              [4, 0, 2],
              [4, 14, 17],
              [5, 0, 3],
              [5, 14, 17],
              [6, 0, 10],
              [6, 14, 17],
              [7, 0, 17],
              [8, 0, 17]
            ]
          },
          {
            title: 'Jaggered Coast L',
            ROWS: 10,
            COLS: 18,
            SHIP_NUM: { A: 1, B: 1, C: 2, D: 2, P: 2, G: 2, U: 1, M: 3 },
            LAND_AREA: [
              [4, 14, 16],
              [5, 0, 2],
              [5, 14, 17],
              [6, 0, 3],
              [6, 14, 17],
              ,
              [7, 0, 10],
              [7, 14, 17],
              [8, 0, 17],
              [9, 0, 17]
            ]
          },
          {
            title: 'Narrow Coast S',
            ROWS: 11,
            COLS: 17,
            SHIP_NUM: { A: 1, B: 1, C: 2, D: 2, P: 3, G: 1, U: 1, M: 3 },
            LAND_AREA: [
              [7, 13, 16],
              [7, 1, 5],
              [8, 13, 16],
              [8, 0, 10],
              [9, 0, 16],
              [10, 0, 16]
            ]
          },
          {
            title: 'Jaggered Coast LL',
            ROWS: 10,
            COLS: 20,
            SHIP_NUM: { A: 1, B: 1, C: 2, D: 2, P: 3, G: 2, U: 1, M: 3 },
            LAND_AREA: [
              [4, 16, 18],
              [5, 1, 4],
              [5, 16, 19],
              [6, 1, 6],
              [6, 16, 19],
              [7, 0, 13],
              [7, 16, 19],
              [8, 0, 19],
              [9, 0, 19]
            ]
          },
          {
            title: 'Narrow Coast M',
            ROWS: 12,
            COLS: 17,
            SHIP_NUM: { A: 1, B: 1, C: 2, D: 3, P: 4, G: 1, U: 1, M: 3 },
            LAND_AREA: [
              [8, 13, 16],
              [8, 1, 5],
              [9, 13, 16],
              [9, 0, 10],
              [10, 0, 16],
              [11, 0, 16]
            ]
          },
          {
            title: 'Jaggered Coast VL',
            ROWS: 10,
            COLS: 21,
            SHIP_NUM: { A: 1, B: 1, C: 2, D: 2, P: 4, G: 2, U: 1, M: 3 },
            LAND_AREA: [
              [4, 16, 18],
              [5, 1, 4],
              [5, 16, 19],
              [6, 1, 6],
              [6, 16, 19],
              [7, 0, 13],
              [7, 16, 19],
              [8, 0, 20],
              [9, 0, 20]
            ]
          },

          {
            title: 'Jaggered Coast XL',
            ROWS: 10,
            COLS: 22,
            SHIP_NUM: { A: 1, B: 1, C: 2, D: 3, P: 4, G: 2, U: 1, M: 3 },
            LAND_AREA: [
              [4, 16, 18],
              [5, 1, 4],
              [5, 16, 19],
              [6, 1, 6],
              [6, 16, 19],
              [7, 0, 13],
              [7, 16, 19],
              [8, 0, 21],
              [9, 0, 21]
            ]
          }
        ]

        let map = {
          title: 'Jaggered Coast SS',
          ROWS: 7,
          COLS: 18,
          SHIP_NUM: { A: 1, B: 1, C: 1, D: 1, P: 2, G: 1, U: 1, M: 3 },
          LAND_AREA: [
            [1, 16, 17],
            [2, 0, 2],
            [2, 16, 17],
            [3, 0, 3],
            [3, 15, 17],
            [4, 15, 17],
            [5, 15, 17],
            [6, 15, 17],
            [4, 0, 7],
            [5, 0, 8],
            [6, 0, 8]
          ]
        }

        const MAX_CARPET_BOMBS = 3
        const SHIP_COLORS = {
          A: 'rgba(255,102,102,0.3)',
          B: 'rgba(102,204,255,0.3)',
          C: 'rgba(102,255,102,0.3)',
          D: 'rgba(255,204,102,0.3)',
          P: 'rgba(204,153,255,0.3)',
          G: 'rgba(255,153,204,0.3)',
          U: 'rgba(255,255,102,0.3)'
        }

        const SHIP_DESCRIPTION = {
          A: 'Aircraft Carrier',
          B: 'Battleship',
          C: 'Cruiser',
          D: 'Destroyer',
          P: 'Airplane',
          G: 'Anti-Aircraft Gun',
          U: 'Underground Bunker'
        }

        const SHIP_TYPE = {
          A: 'S',
          B: 'S',
          C: 'S',
          D: 'S',
          P: 'A',
          G: 'G',
          U: 'G'
        }
        const SHIP_SUNK_DESCRIPTION = {
          A: 'Shot Down',
          G: 'Destroyed',
          S: 'Sunk'
        }

        const SHIP_LETTER_COLORS = {
          A: '#ff6666',
          B: '#66ccff',
          C: '#66ff66',
          D: '#ffcc66',
          P: '#cc99ff',
          G: '#ff99cc',
          U: '#ffff66',
          M: '#ffd166'
        }
        const BASE_SHAPES = [
          {
            letter: 'U',
            symmetry: 'H',
            cells: [
              [0, 0],
              [1, 0],
              [1, 1],
              [1, 2],
              [1, 3],
              [1, 4],
              [0, 4]
            ]
          },
          {
            letter: 'G',
            symmetry: 'S',
            cells: [
              [0, 0],
              [1, 1],
              [0, 2],
              [2, 0],
              [2, 2]
            ]
          },
          {
            letter: 'A',
            symmetry: 'A',
            cells: [
              [0, 0],
              [0, 1],
              [0, 2],
              [0, 3],
              [1, 1],
              [1, 2],
              [1, 3],
              [1, 4]
            ]
          },
          {
            letter: 'P',
            symmetry: 'H',
            cells: [
              [0, 0],
              [1, 0],
              [2, 0],
              [1, 1]
            ]
          },
          {
            letter: 'B',
            symmetry: 'L',
            cells: [
              [0, 0],
              [1, 0],
              [2, 0],
              [3, 0],
              [4, 0]
            ]
          },
          {
            letter: 'C',
            symmetry: 'L',
            cells: [
              [0, 0],
              [1, 0],
              [2, 0],
              [3, 0]
            ]
          },
          {
            letter: 'D',
            symmetry: 'L',
            cells: [
              [0, 0],
              [0, 1],
              [0, 2]
            ]
          }
        ]

        const SHAPES_BY_LETTER = Object.fromEntries(
          BASE_SHAPES.map(base => [base.letter, base])
        )

        // geometry helpers
        const inRange = (r, c) => element =>
          element[0] == r && element[1] <= c && element[2] >= c

        function inBounds(r, c) {
          return r >= 0 && r < map.ROWS && c >= 0 && c < map.COLS
        }
        function isLand(r, c) {
          return map.LAND_AREA.some(inRange(r, c))
        }
        // variant helpers
        function rotate(shape) {
          return shape.map(([r, c]) => [c, -r])
        }
        function flipV(shape) {
          return shape.map(([r, c]) => [-r, c])
        }
        function normalize(shape) {
          const minR = Math.min(...shape.map(s => s[0]))
          const minC = Math.min(...shape.map(s => s[1]))
          return shape.map(([r, c]) => [r - minR, c - minC])
        }
        function asymmetricVariantsOf(cells) {
          let fliped = flipV(cells)
          return [cells, rotate(cells), fliped, rotate(fliped)]
        }
        function symmetricVariantsOf(cells) {
          let variants = [cells]
          for (let i = 0; i < 3; i++) {
            variants.push(rotate(variants[variants.length - 1]))
          }
          return variants
        }
        function straightVariantsOf(cells) {
          return [cells, rotate(cells)]
        }
        function variantsOf(shapeElement) {
          if (!shapeElement || !shapeElement.symmetry || !shapeElement.cells)
            throw new Error(
              'Invalid shapeElement ' + JSON.stringify(shapeElement, null, 2)
            )
          switch (shapeElement.symmetry) {
            case 'A':
              return asymmetricVariantsOf(shapeElement.cells)
            case 'S':
              return [shapeElement.cells]
            case 'H':
              return symmetricVariantsOf(shapeElement.cells)
            case 'L':
              return straightVariantsOf(shapeElement.cells)
            default:
              throw new Error(
                'Unknown symmetry type for ' +
                  JSON.stringify(shapeElement, null, 2)
              ) // The 'null, 2' adds indentation for readability);
          }
        }
        // placement rules: no-touch (including diagonals), and area restrictions
        function canPlace(variant, r0, c0, letter, player) {
          for (const [dr, dc] of variant) {
            const rr = r0 + dr,
              cc = c0 + dc
            if (!inBounds(rr, cc)) return false
            // area rules
            if (SHIP_TYPE[letter] === 'G' && !isLand(rr, cc)) return false
            if (SHIP_TYPE[letter] === 'S' && isLand(rr, cc)) return false
            // no-touch check neighbors
            for (let nr = rr - 1; nr <= rr + 1; nr++)
              for (let nc = cc - 1; nc <= cc + 1; nc++) {
                if (inBounds(nr, nc) && player.grid[nr][nc]) return false
              }
          }
          return true
        }
        function placeVariant(variant, r0, c0, letter, id, player) {
          const placedCells = []
          for (const [dr, dc] of variant) {
            const rr = r0 + dr,
              cc = c0 + dc
            player.grid[rr][cc] = { id, letter }
            placedCells.push([rr, cc])
          }
          return placedCells
        }
        function shuffleArray(array) {
          for (var i = array.length - 1; i > 0; i--) {
            var j = Math.floor(Math.random() * (i + 1))
            var temp = array[i]
            array[i] = array[j]
            array[j] = temp
          }
          return array
        }
        function randomPlaceShape(shapeObj, player) {
          const letter = shapeObj.letter
          const id = shapeObj.id
          const shape = SHAPES_BY_LETTER[letter]
          if (!shape) throw new Error('No shape for letter ' + letter)
          let variants0 = variantsOf(shape)
          const variants = shuffleArray(variants0)

          // try random placements
          const maxAttempts = 20000
          for (let attempt = 0; attempt < maxAttempts; attempt++) {
            for (const variant of variants) {
              // compute bounds for random origin so variant fits
              const maxR = Math.max(...variant.map(s => s[0]))
              const maxC = Math.max(...variant.map(s => s[1]))
              const r0 = Math.floor(Math.random() * (map.ROWS - maxR))
              const c0 = Math.floor(Math.random() * (map.COLS - maxC))
              if (canPlace(variant, r0, c0, letter, player)) {
                return placeVariant(variant, r0, c0, letter, id, player)
              }
            }
          }
          return null
        }
        function sunkDescription(letter) {
          return (
            SHIP_DESCRIPTION[letter] +
            ' ' +
            SHIP_SUNK_DESCRIPTION[SHIP_TYPE[letter]]
          )
        }

        const containerWidth = 520
        const cellSize = containerWidth / map.COLS
        const enemyUI = {
          board: document.getElementById('enemy-board'),
          shots: document.getElementById('enemy-shots'),
          hits: document.getElementById('enemy-hits'),
          sunk: document.getElementById('enemy-sunk'),
          modeStatus: document.getElementById('modeStatus'),
          gameStatus: document.getElementById('gameStatus'),
          carpetBtn: document.getElementById('carpetBtn'),
          revealBtn: document.getElementById('revealBtn'),
          tallyBox: document.getElementById('enemy-tallyBox'),

          displayFleetSunk: function () {
            this.gameStatus.textContent = 'All Ships Destroyed - Well Done!'
            this.modeStatus.textContent = 'Fleet Destroyed'
            this.board.classList.add('destroyed')
          },
          resetBoardSize: function () {
            this.board.style.setProperty('--cols', map.COLS)
            this.board.style.setProperty('--rows', map.ROWS)
            this.board.style.setProperty(
              '--boxSize',
              cellSize.toString() + 'px'
            )
            this.board.innerHTML = ''
          },
          resetTallyBox: function () {
            this.tallyBox.innerHTML = ''
          },
          gridCellAt: function (r, c) {
            const result = this.board.children[r * map.COLS + c]
            if (result && result.classList) return result
            throw new Error(
              'Invalid cell' + JSON.stringify(result) + 'at ' + r + ',' + c
            )
          },
          displayAsRevealed: function (cell, letter) {
            if (cell) {
              cell.style.background =
                SHIP_COLORS[letter] || 'rgba(255, 209, 102, 0.3)'
              cell.style.color = SHIP_LETTER_COLORS[letter] || '#ffd166'
              cell.textContent = letter
            }
          },
          revealShip: function (ship) {
            for (const [r, c] of ship.cells) {
              const cell = this.gridCellAt(r, c)
              this.displayAsRevealed(cell, ship.letter)
            }
          },
          revealAll: function (ships) {
            for (const ship of ships) {
              this.revealShip(ship)
            }
            this.gameStatus.textContent = 'You Gave Up'
            this.modeStatus.textContent = ''
            this.board.classList.add('destroyed')
          },
          displayAsHit: function (cell) {
            cell.classList.add('hit')
            this.gameStatus.textContent = 'Hit'
          },
          cellHit: function (r, c) {
            const cell = this.gridCellAt(r, c)
            this.displayAsHit(cell)
          },
          displayAsMiss: function (cell) {
            //cell.textContent = '•';
            cell.classList.add('miss')
            this.gameStatus.textContent = 'Miss!'
          },
          cellMiss: function (r, c) {
            const cell = this.gridCellAt(r, c)

            this.displayAsMiss(cell)
          },
          displayAsSunk: function (cell, letter) {
            cell.textContent = letter
            cell.style.color = SHIP_LETTER_COLORS[letter] || '#fff'
            cell.style.background =
              SHIP_COLORS[letter] || 'rgba(255,255,255,0.2)'
            cell.classList.remove('hit')
            cell.classList.remove('miss')
          },
          cellSunkAt: function (r, c, letter) {
            const cell = this.gridCellAt(r, c)
            this.displayAsSunk(cell, letter)
          },
          buildTallyRow: function (ships, letter, rowList) {
            const row = document.createElement('div')
            row.className = 'tally-row'
            const matching = ships.filter(s => s.letter === letter)

            matching.forEach(s => {
              const box = document.createElement('div')
              box.className = 'tally-box'
              if (s.sunk) {
                box.textContent = 'X'
                box.style.background = '#ff8080'
                box.style.color = '#400'
              } else {
                box.textContent = s.letter
                box.style.background = SHIP_COLORS[letter] || '#333'
                box.style.color = SHIP_LETTER_COLORS[letter] || '#fff'
              }
              row.appendChild(box)
            })
            rowList.appendChild(row)
          },
          buildBombRow: function (rowList, carpetBombsUsed) {
            const row = document.createElement('div')
            row.className = 'tally-row'

            for (let i = 0; i < MAX_CARPET_BOMBS; i++) {
              const box = document.createElement('div')
              box.className = 'tally-box'

              if (i < carpetBombsUsed) {
                box.textContent = 'X'
                box.style.background = '#999'
              } else {
                box.textContent = 'M'
                box.style.background = SHIP_LETTER_COLORS['M']
              }
              row.appendChild(box)
            }
            rowList.appendChild(row)
          },
          buildTally: function (ships, carpetBombsUsed) {
            this.tallyBox.innerHTML = ''
            this.buildTallyRow(ships, 'P', this.tallyBox)
            const surfaceContainer = document.createElement('div')
            surfaceContainer.setAttribute('style', 'display:flex;gap:40px;')

            const seaColumn = document.createElement('div')
            const landColumn = document.createElement('div')
            const sea = ['A', 'B', 'C', 'D']
            const land = ['G', 'U']
            for (const letter of sea) {
              this.buildTallyRow(ships, letter, seaColumn)
            }
            for (const letter of land) {
              this.buildTallyRow(ships, letter, landColumn)
            }
            surfaceContainer.appendChild(seaColumn)
            surfaceContainer.appendChild(landColumn)

            this.tallyBox.appendChild(surfaceContainer)
            // bombs row
            this.buildBombRow(this.tallyBox, carpetBombsUsed)
          },
          clearVisuals: function () {
            for (const el of this.board.children) {
              el.textContent = ''
              el.style.background = ''
              el.style.color = ''
              el.classList.remove('hit', 'miss')
            }
          }
        }

        const enemy = {
          grid: [],
          ships: [],
          shot: new Set(),
          autoMisses: 0,
          carpetBombsUsed: 0,
          carpetMode: false,
          isRevealed: false,
          boardDestroyed: false,
          UI: enemyUI,

          createShips: function () {
            const ships = []
            let id = 1

            for (const base of BASE_SHAPES) {
              const letter = base.letter
              const symmetry = base.symmetry
              const num = map.SHIP_NUM[letter]
              for (let i = 0; i < num; i++) {
                ships.push({
                  id,
                  symmetry,
                  letter,
                  cells: [],
                  hits: new Set(),
                  sunk: false
                })
                id++
              }
            }
            return ships
          },
          placeAll: function (ships) {
            ships = ships || this.ships

            // attempt whole-board placement; retry if any shape fails
            for (let attempt = 0; attempt < 100; attempt++) {
              this.grid = Array.from({ length: map.ROWS }, () =>
                Array(map.COLS).fill(null)
              )

              let ok = true

              for (const ship of ships) {
                const placed = randomPlaceShape(ship, this)
                if (placed) {
                  ship.cells = placed
                  ship.hit = new Set()
                  ship.sunk = false
                } else {
                  ok = false
                  break
                }
              }

              if (ok) return true
            }
            throw new Error('Failed to place all ships after many attempts')
          },
          revealAll: function () {
            this.UI.revealAll(this.ships)

            this.boardDestroyed = true
            this.isRevealed = true
          },
          updateUI: function (ships) {
            ships = ships || this.ships

            // stats
            this.UI.shots.textContent = (
              this.shot.size - this.autoMisses
            ).toString()

            const hits = ships.reduce((sum, s) => sum + s.hits.size, 0)
            this.UI.hits.textContent = hits.toString()
            const sunkCount = ships.filter(s => s.sunk).length
            this.UI.sunk.textContent = `${sunkCount} / ${ships.length}`

            // mode
            if (this.isRevealed) {
              this.UI.modeStatus.textContent = 'Fleet Revealed'
            } else if (this.boardDestroyed) {
              this.UI.board.classList.toggle('destroyed', this.boardDestroyed)
              this.UI.modeStatus.textContent = 'Fleet Destroyed'
              this.UI.gameStatus.textContent =
                'All Ships Destroyed - Well Done!'
            } else if (this.carpetMode) {
              this.UI.modeStatus.textContent = this.bombStatus()
              this.UI.gameStatus.textContent = 'Click On Square To Drop Bomb'
              this.UI.carpetBtn.innerHTML =
                '<span class="shortcut">S</span>ingle Shot'
            } else {
              this.UI.carpetBtn.innerHTML =
                '<span class="shortcut">M</span>ega Bomb'
              this.UI.modeStatus.textContent = 'Single Shot Mode'
              this.UI.gameStatus.textContent = 'Click On Square To Fire'
            }

            // buttons
            this.UI.carpetBtn.disabled =
              this.boardDestroyed ||
              this.isRevealed ||
              this.carpetBombsUsed >= MAX_CARPET_BOMBS
            this.UI.revealBtn.disabled = this.boardDestroyed || this.isRevealed
            this.UI.buildTally(this.ships, this.carpetBombsUsed)
          },
          onClickCell: function (r, c) {
            if (enemy.boardDestroyed || enemy.isRevealed) return // no action if game over

            if (!enemy.newShotKey(r, c) && !enemy.carpetMode) {
              enemy.UI.gameStatus.textContent = 'Already Shot Here - Try Again'
              return
            }

            if (enemy.carpetMode) {
              // Mega Bomb mode: affect 3x3 area centered on (r,c)
              if (enemy.carpetBombsUsed >= MAX_CARPET_BOMBS) {
                enemy.UI.gameStatus.textContent = 'No Mega Bombs Left'
                return
              }
              enemy.processCarpetBomb(r, c)
              return
            }
            enemy.processShot(r, c)
          },
          bombStatus: function () {
            return `Bomb Mode (${MAX_CARPET_BOMBS - this.carpetBombsUsed} left)`
          },

          recordAutoMiss: function (r, c) {
            const key = this.createShotKey(r, c)
            if (!key) return // already shot here
            this.autoMisses++
            this.UI.cellMiss(r, c)
          },
          markSunk: function (ship) {
            ship.sunk = true
            this.UI.gameStatus.textContent = sunkDescription(ship.letter)
            for (const [r, c] of ship.cells) {
              // surrounding water misses
              for (let dr = -1; dr <= 1; dr++)
                for (let dc = -1; dc <= 1; dc++) {
                  const rr = r + dr
                  const cc = c + dc
                  if (inBounds(rr, cc)) {
                    this.recordAutoMiss(rr, cc)
                  }
                }
              this.UI.cellSunkAt(r, c, ship.letter)
            }
            this.checkFleetSunk()
          },
          recordFleetSunk: function () {
            this.UI.displayFleetSunk()
            this.boardDestroyed = true
          },
          checkFleetSunk: function () {
            if (this.ships.every(s => s.sunk)) {
              this.recordFleetSunk()
            }
          },
          shipCellAt: function (r, c) {
            return this.grid[r]?.[c]
          },
          hasShot: function (r, c) {
            const key = `${r},${c}`
            return this.shot.has(key)
          },
          newShotKey: function (r, c) {
            const key = `${r},${c}`
            if (this.shot.has(key)) return null
            return key
          },

          createShotKey: function (r, c) {
            const key = this.newShotKey(r, c)
            if (key) {
              this.shot.add(key)
            }
            return key
          },
          fireShot: function (r, c, key) {
            const shipCell = this.shipCellAt(r, c)
            if (!shipCell) {
              this.UI.cellMiss(r, c)

              return { hit: false, sunk: '' }
            }
            // check for hit
            const hitShip = this.ships.find(s => s.id === shipCell.id)
            if (!hitShip) {
              this.UI.cellMiss(r, c)

              return { hit: false, sunk: '' }
            }
            // it's a hit
            hitShip.hits.add(key)

            this.UI.cellHit(r, c)

            if (hitShip.hits.size === hitShip.cells.length) {
              // ship sunk
              this.markSunk(hitShip)

              return { hit: true, sunkLetter: hitShip.letter }
            }

            return { hit: true, sunkLetter: '' }
          },
          processShot: function (r, c) {
            const key = this.createShotKey(r, c)
            if (key === null) {
              // if we are here, it is because of carpet bomb, so we can just
              return { hit: false, sunk: '' }
            }

            const result = this.fireShot(r, c, key)

            this.updateUI(this.ships)
            return result

            v
          },
          processCarpetBomb: function (r, c) {
            /*
    if (this.hasShot(r, c)) {
      this.UI.gameStatus.textContent = 'Already Shot Here - Try Again'
      return // already shot here
    }
      */

            let hits = 0
            let sunks = ''
            this.carpetBombsUsed++
            for (let dr = -1; dr <= 1; dr++) {
              for (let dc = -1; dc <= 1; dc++) {
                const nr = r + dr
                const nc = c + dc
                if (inBounds(nr, nc)) {
                  const result = this.processShot(nr, nc)
                  if (result && result.hit) hits++
                  if (result && result.sunkLetter) sunks += result.sunkLetter
                }
              }
            }

            // update status
            if (this.boardDestroyed) {
              // already handled  in updateUI
            } else if (hits === 0) {
              this.UI.gameStatus.textContent =
                'The Mega Bomb missed everything!'
            } else if (sunks.length === 0) {
              this.UI.gameStatus.textContent = hits.toString() + ' Hits'
            } else if (sunks.length === 1) {
              this.UI.gameStatus.textContent =
                hits.toString() + ' Hits and ' + sunkDescription(sunks)
            } else {
              let message = hits.toString() + ' Hits,'
              for (let sunk of sunks) {
                message += ' and ' + sunkDescription(sunk)
              }
              message += ' Destroyed'
              this.UI.gameStatus.textContent = message
            }
            this.UI.modeStatus.textContent = this.bombStatus()
            if (enemy.carpetBombsUsed >= MAX_CARPET_BOMBS) {
              enemy.carpetMode = false
              enemy.UI.modeStatus.textContent = 'Single Shot Mode'
            }
          },
          onClickCarpetMode: function () {
            if (!enemy.isRevealed && enemy.carpetBombsUsed < MAX_CARPET_BOMBS) {
              enemy.carpetMode = !enemy.carpetMode
              enemy.updateUI(enemy.ships)
            }
          },
          onClickReveal: function () {
            if (!enemy.isRevealed) {
              enemy.revealAll()
              enemy.updateUI(enemy.ships)
            }
          },
          wireupButtons: function () {
            this.UI.carpetBtn.addEventListener('click', enemy.onClickCarpetMode)
            this.UI.revealBtn.addEventListener('click', enemy.onClickReveal)
          },
          resetModel: function () {
            this.carpetMode = false
            this.carpetBombsUsed = 0
            this.boardDestroyed = false
            this.isRevealed = false
            this.shot.clear()
            this.autoMisses = 0
            this.ships = this.createShips()
          },
          buildBoard: function () {
            this.UI.board.innerHTML = ''
            for (let r = 0; r < map.ROWS; r++) {
              for (let c = 0; c < map.COLS; c++) {
                const el = document.createElement('div')
                const land = isLand(r, c)
                const c1 = c + 1
                const r1 = r + 1
                el.className = 'cell'
                el.classList.add(land ? 'land' : 'sea')
                const checker = (r + c) % 2 === 0
                el.classList.add(checker ? 'light' : 'dark')
                if (!land && c1 < map.COLS && isLand(r, c1)) {
                  el.classList.add('rightEdge')
                }
                if (c !== 0 && !land && isLand(r, c - 1)) {
                  el.classList.add('leftEdge')
                }
                if (r1 < map.ROWS && land !== isLand(r1, c)) {
                  el.classList.add('bottomEdge')
                }
                el.dataset.r = r
                el.dataset.c = c
                el.addEventListener('click', () => enemy.onClickCell(r, c))
                this.UI.board.appendChild(el)
              }
            }
            // update destroyed state class
            this.UI.board.classList.toggle('destroyed', this.boardDestroyed)
          },
          resetUI: function (ships) {
            this.UI.board.innerHTML = ''
            this.UI.board.classList.remove('destroyed')
            this.UI.gameStatus.textContent = 'Click On Square To Fire'
            this.UI.modeStatus.textContent = 'Single Shot Mode'

            this.buildBoard()
            this.placeAll(ships)
            this.UI.clearVisuals()
            this.updateUI(ships)
          }
        }

        const newGameBtn = document.getElementById('newGame')
        enemy.UI.resetBoardSize()

        function newGame() {
          enemy.resetModel()
          enemy.resetUI(enemy.ships)
        }

        // wire buttons
        newGameBtn.addEventListener('click', newGame)
        chooseMap.addEventListener('change', function () {
          const index = this.value
          map = maps[index]
          enemy.UI.resetBoardSize()
          newGame()
        })
        enemy.wireupButtons()
        document.addEventListener('keydown', function (event) {
          switch (event.key) {
            case 'r':
            case 'R':
              newGame()
              break
            case 'v':
            case 'V':
              enemy.onClickReveal()
              break
            case 'm':
            case 'M':
              if (!enemy.carpetMode) enemy.onClickCarpetMode()
              break
            case 's':
            case 'S':
              if (enemy.carpetMode) enemy.onClickCarpetMode()
              break
          }
        })

        let mapId = 0
        maps.forEach(mapOption => {
          let option = document.createElement('option')
          option.value = mapId
          option.textContent = mapOption.title
          chooseMap.appendChild(option)
          mapId++
        })

        // initial
        newGame()
      })()
      //]]>
    </script>
  </body>
</html>
